From 9251ac9d92deffbd77cfdbed59506b9514d77cd6 Mon Sep 17 00:00:00 2001
From: Dustin Spicuzza <dustin@virtualroadside.com>
Date: Sun, 16 Aug 2015 01:53:07 -0400
Subject: [PATCH] Custom directsoundsink patch for Exaile

---
 configure.ac                           |  5 ++-
 sys/directsound/gstdirectsoundplugin.c |  4 +-
 sys/directsound/gstdirectsoundsink.c   | 74 +++++++++++++++++++++++++++++++++-
 sys/directsound/gstdirectsoundsink.h   |  6 +++
 4 files changed, 83 insertions(+), 6 deletions(-)

diff --git a/configure.ac b/configure.ac
index 6b44cea..7efe850 100644
--- a/configure.ac
+++ b/configure.ac
@@ -388,7 +388,7 @@ AG_GST_CHECK_FEATURE(DIRECTSOUND, [DirectSound plug-in], directsoundsink, [
   save_LIBS="$LIBS"
   CFLAGS="$CFLAGS $DIRECTSOUND_CFLAGS"
   LDFLAGS="$LDFLAGS $DIRECTSOUND_LDFLAGS"
-  LIBS="$LIBS -ldsound -ldxerr9 -luser32"
+  LIBS="$LIBS -ldsound -ldxerr9 -luser32 -lole32"
   AC_MSG_CHECKING(for DirectSound LDFLAGS)
   AC_LINK_IFELSE([AC_LANG_PROGRAM([[
 #include <windows.h>
@@ -397,6 +397,7 @@ AG_GST_CHECK_FEATURE(DIRECTSOUND, [DirectSound plug-in], directsoundsink, [
 ]], [[
   DXGetErrorString9 (0);
   DirectSoundCreate(NULL, NULL, NULL);
+  CLSIDFromString(NULL, NULL);
 ]])
 ],
     [HAVE_DIRECTSOUND="yes"],
@@ -408,7 +409,7 @@ AG_GST_CHECK_FEATURE(DIRECTSOUND, [DirectSound plug-in], directsoundsink, [
 
   if test "x$HAVE_DIRECTSOUND" = "xyes";  then
     dnl this is much more than we want
-    DIRECTSOUND_LIBS="-ldsound -ldxerr9 -luser32"
+    DIRECTSOUND_LIBS="-ldsound -ldxerr9 -luser32 -lole32"
     AC_SUBST(DIRECTSOUND_CFLAGS)
     AC_SUBST(DIRECTSOUND_LDFLAGS)
     AC_SUBST(DIRECTSOUND_LIBS)
diff --git a/sys/directsound/gstdirectsoundplugin.c b/sys/directsound/gstdirectsoundplugin.c
index faee215..a3183f5 100644
--- a/sys/directsound/gstdirectsoundplugin.c
+++ b/sys/directsound/gstdirectsoundplugin.c
@@ -35,7 +35,7 @@
 static gboolean
 plugin_init (GstPlugin * plugin)
 {
-  if (!gst_element_register (plugin, "directsoundsink", GST_RANK_PRIMARY,
+  if (!gst_element_register (plugin, "exailedirectsoundsink", GST_RANK_PRIMARY,
           GST_TYPE_DIRECTSOUND_SINK))
     return FALSE;
 
@@ -45,5 +45,5 @@ plugin_init (GstPlugin * plugin)
 GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
     GST_VERSION_MINOR,
     directsound,
-    "Direct Sound plugin library",
+    "Direct Sound plugin library (Exaile)",
     plugin_init, VERSION, "LGPL", GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN)
diff --git a/sys/directsound/gstdirectsoundsink.c b/sys/directsound/gstdirectsoundsink.c
index 56b0418..3788cf9 100644
--- a/sys/directsound/gstdirectsoundsink.c
+++ b/sys/directsound/gstdirectsoundsink.c
@@ -101,6 +101,10 @@ static gdouble gst_directsound_sink_get_volume (GstDirectSoundSink * sink);
 static void gst_directsound_sink_set_mute (GstDirectSoundSink * sink,
     gboolean mute);
 static gboolean gst_directsound_sink_get_mute (GstDirectSoundSink * sink);
+static const gchar *gst_directsound_sink_get_device (GstDirectSoundSink *
+    dsoundsink);
+static void gst_directsound_sink_set_device (GstDirectSoundSink * dsoundsink,
+    const gchar * device_id);
 
 static gboolean gst_directsound_sink_is_spdif_format (GstAudioRingBufferSpec *
     spec);
@@ -124,7 +128,8 @@ enum
 {
   PROP_0,
   PROP_VOLUME,
-  PROP_MUTE
+  PROP_MUTE,
+  PROP_DEVICE
 };
 
 #define gst_directsound_sink_parent_class parent_class
@@ -137,6 +142,11 @@ gst_directsound_sink_finalize (GObject * object)
 {
   GstDirectSoundSink *dsoundsink = GST_DIRECTSOUND_SINK (object);
 
+  if (dsoundsink->device_id) {
+    g_free (dsoundsink->device_id);
+    dsoundsink->device_id = NULL;
+  }
+
   g_mutex_clear (&dsoundsink->dsound_lock);
 
   G_OBJECT_CLASS (parent_class)->finalize (object);
@@ -189,6 +199,12 @@ gst_directsound_sink_class_init (GstDirectSoundSinkClass * klass)
           "Mute state of this stream", DEFAULT_MUTE,
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
+  g_object_class_install_property (gobject_class,
+      PROP_DEVICE,
+      g_param_spec_string ("device", "Device",
+          "DirectSound playback device as a GUID string",
+          NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
   gst_element_class_set_static_metadata (element_class,
       "Direct Sound Audio Sink", "Sink/Audio",
       "Output to a sound card via Direct Sound",
@@ -203,6 +219,7 @@ gst_directsound_sink_init (GstDirectSoundSink * dsoundsink)
 {
   dsoundsink->volume = 100;
   dsoundsink->mute = FALSE;
+  dsoundsink->device_id = NULL;
   dsoundsink->pDS = NULL;
   dsoundsink->cached_caps = NULL;
   dsoundsink->pDSBSecondary = NULL;
@@ -226,6 +243,9 @@ gst_directsound_sink_set_property (GObject * object,
     case PROP_MUTE:
       gst_directsound_sink_set_mute (sink, g_value_get_boolean (value));
       break;
+    case PROP_DEVICE:
+      gst_directsound_sink_set_device (sink, g_value_get_string (value));
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -245,6 +265,9 @@ gst_directsound_sink_get_property (GObject * object,
     case PROP_MUTE:
       g_value_set_boolean (value, gst_directsound_sink_get_mute (sink));
       break;
+    case PROP_DEVICE:
+      g_value_set_string (value, gst_directsound_sink_get_device (sink));
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -378,22 +401,53 @@ gst_directsound_sink_query (GstBaseSink * sink, GstQuery * query)
   return res;
 }
 
+static LPGUID
+string_to_guid (const gchar * str)
+{
+  HRESULT ret;
+  gunichar2 *wstr;
+  LPGUID out;
+
+  wstr = g_utf8_to_utf16 (str, -1, NULL, NULL, NULL);
+  if (!wstr)
+    return NULL;
+
+  out = g_malloc (sizeof (GUID));
+  ret = CLSIDFromString ((LPOLESTR) wstr, out);
+  g_free (wstr);
+  if (ret != NOERROR) {
+    g_free (out);
+    return NULL;
+  }
+
+  return out;
+}
+
 static gboolean
 gst_directsound_sink_open (GstAudioSink * asink)
 {
   GstDirectSoundSink *dsoundsink;
   HRESULT hRes;
+  LPGUID lpGuid = NULL;
 
   dsoundsink = GST_DIRECTSOUND_SINK (asink);
 
+  if (dsoundsink->device_id)
+    lpGuid = string_to_guid (dsoundsink->device_id);
+
   /* create and initialize a DirecSound object */
-  if (FAILED (hRes = DirectSoundCreate (NULL, &dsoundsink->pDS, NULL))) {
+  if (FAILED (hRes = DirectSoundCreate (lpGuid, &dsoundsink->pDS, NULL))) {
     GST_ELEMENT_ERROR (dsoundsink, RESOURCE, OPEN_READ,
         ("gst_directsound_sink_open: DirectSoundCreate: %s",
             DXGetErrorString9 (hRes)), (NULL));
+    if (lpGuid)
+      g_free (lpGuid);
     return FALSE;
   }
 
+  if (lpGuid)
+    g_free (lpGuid);
+
   if (FAILED (hRes = IDirectSound_SetCooperativeLevel (dsoundsink->pDS,
               GetDesktopWindow (), DSSCL_PRIORITY))) {
     GST_ELEMENT_ERROR (dsoundsink, RESOURCE, OPEN_READ,
@@ -874,3 +928,19 @@ gst_directsound_sink_get_mute (GstDirectSoundSink * dsoundsink)
 {
   return FALSE;
 }
+
+static const gchar *
+gst_directsound_sink_get_device (GstDirectSoundSink * dsoundsink)
+{
+  return dsoundsink->device_id;
+}
+
+static void
+gst_directsound_sink_set_device (GstDirectSoundSink * dsoundsink,
+    const gchar * device_id)
+{
+  if (dsoundsink->device_id) {
+    g_free (dsoundsink->device_id);
+  }
+  dsoundsink->device_id = g_strdup (device_id);
+}
diff --git a/sys/directsound/gstdirectsoundsink.h b/sys/directsound/gstdirectsoundsink.h
index 3a83181..e50f543 100644
--- a/sys/directsound/gstdirectsoundsink.h
+++ b/sys/directsound/gstdirectsoundsink.h
@@ -40,6 +40,9 @@
 #include <ks.h> 
 #include <ksmedia.h> 
 
+#define GstDirectSoundSink GstExaileDirectSoundSink
+#define GstDirectSoundSinkClass GstExaileDirectSoundSinkClass
+
 G_BEGIN_DECLS
 #define GST_TYPE_DIRECTSOUND_SINK            (gst_directsound_sink_get_type())
 #define GST_DIRECTSOUND_SINK(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DIRECTSOUND_SINK,GstDirectSoundSink))
@@ -74,6 +77,9 @@ struct _GstDirectSoundSink
   /* current volume setup by mixer interface */
   glong volume;
   gboolean mute;
+  
+  /* current directsound device ID */
+  gchar * device_id;
 
   GstCaps *cached_caps;
   /* lock used to protect writes and resets */
-- 
2.4.3

